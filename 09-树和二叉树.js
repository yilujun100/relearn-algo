// 09 | 树和二叉树：分支关系与层次结构下，如何有效实现增删查？
// 树是什么
// 树是由节点和边组成的，不存在环的一种数据结构。
// 树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根节点后，得到的若干个子结构也是树，通常称作子树。
// 在一棵树中，根据节点之间层次关系的不同，对节点的称呼也有所不同。（父节点、子节点、兄弟节点、根节点、叶子节点）
// 当有了一棵树之后，还需要用深度、层来描述这棵树中节点的位置。节点的层次从根节点算起，根为第一层，根的“孩子”为第二层，跟的“孩子”的
// “孩子”为第三层，依此类推。树中节点的最大层次数，就是这棵树的树深（称为深度，也称为高度）。
// 二叉树是什么
// 在树的大家族中，有一种被高频使用的特殊树，它就是二叉树。在二叉树中，每个节点最多有两个分支，即每个节点最多有两个子节点，分别称作
// 左子节点和右子节点。
// 在二叉树中，有两个特殊的类型：
// 满二叉树，定义为除了叶子节点外，所有节点都有 2 个子节点。
// 完全二叉树，定义为除了最后一层以外，其他层的节点个数都达到最大，并且最后一层的叶子节点都靠左排列。

// 树的基本操作
// 可以发现，我们以前的数据结构都是“一对一”的关系，即前面的数据只跟下面的一个数据产生了连接关系，例如链表、栈、队列等。而树结构则是
// “一对多”的关系，即前面的父节点，跟下面若干个子节点产生了连接关系。
// 要在数据结构中，查找具有某个数值特性的数据需要遍历每一条数据。这在“一对一”的结构中，直接按顺序访问就好了。可是，树是“一对多”的关系，
// 那么我们该如何进行数据的遍历，才能保证每条数据都会被访问一次且没有遗漏呢？我们只有解决了遍历问题，才能通过树来进行数据的增删查操作。
// 其实，遍历一棵树，有非常经典的三种方法，分别是前序遍历、中序遍历、后序遍历。这里的序指的是父节点的遍历顺序，前序就是先遍历父节点，
// 中序就是中间遍历父节点 ，后序就是最后遍历父节点。不管哪种遍历，都是通过递归调用完成的。
// 前序遍历，对树中的任意节点来说，先打印这个节点，然后前序遍历它的左子树，最后前序遍历它的右子树。
// 中序遍历，对树中的任意节点来说，先中序遍历它的左子树，然后打印这个节点，最后中序遍历它的右子树。
// 后序遍历，对树中的任意节点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。
// 下面通过代码实现二叉树的三种遍历：
// 前序遍历
const preOrderTraverse = node => {
  if (node === null) return;
  console.log(node.val + '');
  preOrderTraverse(node.left);
  preOrderTraverse(node.right);
};
// 中序遍历
const inOrderTraverse = node => {
  if (node === null) return;
  inOrderTraverse(node.left);
  console.log(node.val + '');
  inOrderTraverse(node.right);
};
// 后序遍历
const postOrderTraverse = node => {
  if (node === null) return;
  postOrderTraverse(node.left);
  postOrderTraverse(node.right);
  console.log(node.val + '');
};
// 不难发现，二叉树遍历过程中，每个节点都被访问了一次，其时间复杂度是 O(n)。接着，在找到位置后，执行增加和删除数据的操作时，我们只
// 需要通过指针建立连接关系就可以了。对于没有任何特殊性质的二叉树而言，抛开遍历的时间复杂度以外，真正执行增加和删除操作的时间复杂度
// 是 O(1)。树数据的查找跟链表一样，都需要遍历每一个数据去判断，所以时间复杂度是 O(n)。
// 二叉树的增删查操作很普通，时间复杂度与链表并没有太多差别。但当二叉树具备一些特性的时候，则可以利用这些特性实现时间复杂度的降低。
// 二叉查找树的特性
// 二叉查找树（也称作二叉搜索树）具备以下几个特性：
// 在二叉查找树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值。
// 在二叉查找树中的任意一个节点，其右子树中的每个节点的值，都要大于这个节点的值。
// 在二叉查找树中，会尽可能规避两个节点数值相等的情况。
// 对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。
// 二叉查找树的查找操作
// 在利用二叉查找树执行查找操作时，我们可以进行以下判断：
// 首先判断根节点是否等于要查找的数据，如果是就返回。
// 如果根节点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子节点。
// 如果根节点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子节点。
// 这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。
// 二叉查找树的插入操作
// 在二叉查找树执行插入操作也很简单。从根节点开始，如果要插入的数据比根节点的数据大，且根节点的右子节点不为空，则在根节点的右子树中继续
// 尝试执行插入操作。直到找到为空的子节点执行插入动作。
// 二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到
// 查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。
// 二叉查找树的删除操作会比较复杂，这是因为删除完某个节点后的树，仍然要满足二叉查找树的性质。我们分为下面三种情况讨论。
// 情况一，如果要删除的节点是某个叶子节点，则直接删除，将其父节点指针指向 null 即可。
// 情况二，如果要删除的节点只有一个子节点，只需要将其父节点指向的子节点的指针换成其子节点的指针即可。
// 情况三，如果要删除的节点有两个子节点，则有两种可行的操作方式。
// 第一种，找到这个节点的左子树中最大的节点，替换要删除的节点。
// 第二种，找到这个节点的右子树中最小的节点，替换要删除的节点。

// 树的案例
// 输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如
// deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog, door, deep。输入 cat，输出 true；输入 home，输出 false。
// 假设采用最暴力的办法，估算一下时间复杂度。假设字符串集合包含了 n 个字符串，其中的字符串平均长度为 m。那么新来的一个字符串，需要与每个
// 字符串的每个字符进行匹配。则时间复杂度为 O(nm)。
// 但在 nm 的复杂度中，显然存在很多的无效匹配。例如，输入 home 时，6 个字符串都没有 h 开头的，则不需要进行后续的匹配。因此，如果可以
// 通过对字符前缀进行处理，就可以最大限度地减少无谓的字符串比较，从而提高查询效率。这就是“用空间换时间”的思想，再利用共同前缀来提高查询效率。
// 其实，这个问题利用树结构也可以完成。我们对字符串建立一个树结构，它将字符串集合的前缀进行合并，每个根节点到叶子节点的链条就是一个字符串。
// 这个树结构也称作 Trie 树，或字典树。它具有三个特点：
// 第一，根节点不包含字符；
// 第二，除根节点外每一个节点都只包含一个字符；
// 第三，从根节点到某一叶子节点，路径上经过的字符连接起来，即为集合中的某个字符串。
// 这个问题的解法可以拆解为以下两个步骤：
// 第一步，根据候选字符串集合，建立字典树。这需要使用数据插入的动作。
// 第二步，对于一个输入字符串，判断它能否在这个树结构中走到叶子节点。如果能，则出现过。
