// 16 | 真题案例（一）：算法思维训练
// 在前面课时中，我们已经学习了解决代码问题的方法论。宏观上，它可以分为以下 4 个步骤：
// 复杂度分析。估算问题中复杂度的上限和下限。
// 定位问题。根据问题类型，确定采用何种算法思维。
// 数据操作分析。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。
// 编码实现。
// 这套方法论的架构，是解决绝大多数代码问题的基本步骤。本课时，我们将在一些更开放的题目中进行演练，继续训练算法思维。
// 算法思维训练题
// 例题 1：斐波拉契数列
// 斐波拉契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144...。你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；
// 也就睡 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。在这个数列中的数字，就被称为斐波拉契数。
// 【题目】写一个函数，输入 x，输出斐波拉契数列中第 x 位的元素。例如，输入 4，输出 2；输入 9，输出 21。
// 要求：需要用递归的方式来实现。
// 【解析】在本课时开头，我们复习了解决代码问题的方法论，下面我们按照解题步骤进行详细分析。
// 首先我们还是先做好复杂度的分析
// 题目中要求要用递归的方式来实现，而递归的次数与 x 的具体数值有非常强的关系。因此，此时的时间复杂度应该是关于输入变量 x 的数值大小的函数。
// 至于问题定位
// 因为题目中已经明确了要采用递归去解决。所以也不用再去做额外的分析和判断了。
// 那么，如何使用递归呢？我们需要依赖斐波那契数列的重要特性“某个数等于它前面两个数的和”。也就是说，要求出某个位置 x 的数值，需要先求出 x-1
// 的位置是多少和 x-2 的位置是多少。递归同时还需要终止条件，对应于斐波那契数列的性质，就是起始两个元素，分别为 0 和 1。
// 数据操作方面
// 斐波那契数列需要对数字进行求和。而且所有的计算，都是依赖最原始的 0 和 1 进行。因此，这道题是不需要设计什么复杂的数据结构的。
// 最后，实现代码
// 我们围绕递归的性质进行开发，去试着写出递归体和终止条件。代码如下：
const fib = n => {
  if (n === 1) {
    return 0;
  }
  if (n === 2) {
    return 1;
  }
  return fib(n - 1) + fib(n - 2);
};
console.log(fib(5));
// 例题2：判断一个数组中是否存在某个数
// 【题目】给定一个经过任意位数的旋转后的排序数组，判断某个数是否在里面。
// 例如，对于一个给定数组 [4, 5, 6, 7, 0, 1, 2]，它是将一个有序数组的前三位旋转地放在了数组末尾。假设输入的 target 等于 0，则输出
// 答案是 4，即 0 所在的位置下标是 4。如果输入 3，则返回 -1。
// 【解析】这道题目依旧是按照解决代码问题的方法论的步骤进行分析。
// 先做复杂度分析
// 这个问题就是判断某个数字是否在数组中，因此，复杂度极限就是全部遍历地去查找，也就是 O(n) 的复杂度。
// 接着，进行定位问题的环节中
// 这个问题有很多关键字，因此能够让你立马锁定问题。例如，判断某个数是否在数组里面，这就是一个查找问题。
// 然后，我们来做数据操作分析
// 原数组是经过某些处理的排序数组，也就是说原数组是有序的。有序和查找，你就会很快地想到，这个问题极有可能用二分查找的方式去解决，时间复杂度
// 是 O(logn)，相比上面 O(n) 的基线也是有显著的提高。
// 在利用二分查找时，更多的是判断，基本没有数据的增删操作，因此不需要太多地定义复杂的数据结构。
// 分析到这里，解决方案已经非常明朗了，就是利用二分查找的方法，在 O(logn) 的时间复杂度下去解决这个问题。二分查找可以通过递归来实现。而
// 每次递归的关键点在于，根据切分的点（最中间的那个数字），确定是向左走还是向右走。这也是这个例题中唯一的难点了。
// 试想一下，在一个旋转后的有序数组中，利用中间元素作为切分点得到的两个子数组有什么样的性质。经过枚举不难发现，这两个子数组中，一定存在一个
// 数组是有序的。也可能出现一个极端情况，二者都是有序的。
// 对于有序的一边，我们是很容易判断目标值，是否在这个区间内的。如果在其中，也说明了目标值不在另一边的旋转有序组里；反之亦然。
// 当我们知道了目标值在左右哪边之后，就可以递归地调用旋转有序的二分查找了。之所以可以递归调用，是因为，对于旋转有序组，这个问题和原始问题
// 完全一致，可以调用。对于有序组，它是旋转有序的特殊情况（即旋转 0 位），也一定是可以通过递归的方法去实现查找的。直到不断二分后，搜索空间
// 只有 1 位数字，直接判断是否找到即可。
// 最后，实现代码
const bs = (arr, target, begin, end) => {
  if (begin === end) {
    // 经过了层层二分，最终 begin 和 end 变成了相等的两个变量，则进入到终止条件
    if (target === arr[begin]) {
      return begin;
    } else {
      return -1;
    }
  }
  let middle = Math.floor((begin + end) / 2);
  if (target === arr[middle]) {
    // 目标值与分裂值如果相等，则查找到结果并返回
    return middle;
  }
  if (arr[begin] <= arr[middle - 1]) {
    // 左边有序
    // 假设左边有序，则还需要判断 target 是否在有序区间内
    // 如果在，则继续递归调用 bs(arr, target, begin, middle - 1)
    // 如果不在有序部分，则说明 target 在另一边的旋转有序中，则调用 bs(arr, target, middle + 1, end)
    if (arr[begin] <= target && target <= arr[middle - 1]) {
      return bs(arr, target, begin, middle - 1);
    } else {
      return bs(arr, target, middle + 1, end);
    }
  } else {
    // 右边有序
    if (arr[middle + 1] <= target && target <= arr[end]) {
      return bs(arr, target, middle + 1, end);
    } else {
      return bs(arr, target, begin, middle - 1);
    }
  }
};
const arr = [4, 5, 6, 7, 0, 1, 2];
const target = 7;
console.log(bs(arr, target, 0, arr.length - 1));
// 例题3：求解最大公共子串
// 【题目】输入两个字符串，用动态规划的方法，求解出最大公共子串。
// 例如，输入 a = "13452439"， b = "123456"。由于字符串"345"同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长的子串。因此输出"345"。
// TODO: 动态规划求解
