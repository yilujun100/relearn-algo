// 19 | 真题案例（四）：大厂真题实战演练
// 例题 1：判断数组中所有的数字是否只出现一次
// 【题目】判断数组中所有的数字是否只出现一次。给定一个个数字 arr，判断数组 arr 中是否所有的数字都只出现过一次。约束时间复杂度为 O(n)。
// 例如，arr = {1, 2, 3}，输出 YES。又如，arr = {1, 2, 1}，输出 NO。
// 【解析】我们先来看一下复杂度。判断是否所有数字都只出现一次，很显然我们需要对每个数字进行遍历，因此时间复杂度为 O(n)。而每次的遍历，
// 都要判断当前元素在先前已经扫描过的区间内是否出现过。由于此时并没有额外信息（例如数组有序）输入，因此，还需要 O(n) 的时间进行判断。综合
// 起来看就是 O(n^2) 的时间复杂度。这显然与题目的要求不符合。
// 然后我们来定位问题。根据题目来看，你可以理解这是一个数据去重的问题。但是由于我们并没有学过太多解决这类问题的算法思维，因此我们不妨再从
// 数据操作的视角看一下。
// 按照解题步骤，接下来我们需要做数据操作分析。每轮迭代需要去判断当前元素在先前已经扫描过的区间内是否出现过，这就是一个查找的动作。也就是说，
// 每次迭代需要对数据进行数值特征方面的查找。这个题目只需要判断是否有重复，并不需要新增、删除的动作。
// 在优化数值特性的查找时，我们应该立马想到哈希表。因为它能在 O(1) 的时间内完成查找动作。这样，整体的时间复杂度就可以被降低为 O(n) 了。
// 与此同时，空间复杂度也提高到了 O(n)。
const isUnique = arr => {
  const map = new Map();
  for (let i = 0; i < arr.length; i++) {
    if (map.has(arr[i])) {
      return false;
    }
    map.set(arr[i], 1);
  }
  return true;
};
const arr = [1, 2, 3];
if (isUnique(arr)) {
  console.log('YES');
} else {
  console.log('NO');
}
// 这道题目比较简单，属于数据结构的应用范畴。
// 例题 2：找出数组中出现次数超过数组长度一半的元素
// 【题目】假设在一个数组中，有一个数字出现的次数超过数组长度的一半，现在要求你找出这个数字。
// 你可以假设一定存在这个出现次数超过数组长度的一半的数字，即不用考虑输入不合法的情况。要求时间复杂度是 O(n)，空间复杂度是 O(1)。例如，
// 输入 a = {1,2,1,1,2,4,1,5,1}，输出 1。
// 【解析】先来看一下时间复杂度的分析。一个直观想法是，一边扫描一边记录每个元素出现的次数，并利用 k-v 结构的哈希表存储。例如，一次扫描后，
// 得到元素-次数（1-5，2-2，4-1，5-1）的字典。接着再在这个字典里去找到次数最多的元素。这样的时间复杂度和空间复杂度都是 O(n)。不过可惜，
// 这并不满足题目的要求。
// 接着，我们需要定位问题。从问题出发，这并不是某个特定类型的问题。而且既然空间复杂度限定是 O(1)，也就意味着不允许使用任何复杂的数据结构。
// 也就是说，数据结构优化不可以用，算法思维的优化也不可以用。
// 面对这类问题，我们只能从问题出发，看还有哪些信息我们没有使用上。题目中有一个重要的信息是，这个出现超过半数的数字一定存在。回想我们上边
// 的解法，它可以找到出现次数最多的数字，但没有使用到“必然超过半数”这个重要的信息。
// 分析到这里，我们不妨想一下这个场景。假设现在三国交战，其中 A 国的兵力比 B 国和 C 国的总和还多。那么人们就常常会说，哪怕是 A 国士兵
// “一个碰一个”地和另外两国打消耗战，都能取得最后的胜利。
// 说到这里，不知道你有没有一些发现。“一个碰一个”的思想，那就是如果相等则加 1，如果不等则减 1。这样，只需要记录一个当前的缓存元素变量和
// 一个次数统计变量就可以了。
const s1 = () => {
  const a = [1, 2, 2, 1, 1, 4, 1, 5, 1];
  let result = a[0];
  let times = 1;
  for (let i = 1; i < a.length; i++) {
    if (a[i] !== result) {
      times--;
    } else {
      times++;
    }
    if (times === -1) {
      // 当次数降低为 -1 时，则发生了结果跳转。此时，result 更新为 a[i]，次数重新置为 1。
      times = 1;
      result = a[i];
    }
  }
  console.log(result);
};
// 例题 3：给定一个方格棋盘，从左上角出发到右下角有多少种方法
// 【题目】在一个方格棋盘里，左上角是起点，右下角是终点。每次只能向右或向下，移向相邻的格子。同时，棋盘中有若干个格子是陷阱，不可经过，必须
// 绕开行走。
// 要求用动态规划的方法，求出从起点到终点总共有多少种不同的路径。例如，输入二维矩阵 m 代表棋盘，其中，1 表示格子可达，-1 表示陷阱。输出可行
// 的路径数量为 2。
// TODO: resolve
